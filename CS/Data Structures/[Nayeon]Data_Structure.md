# 📌 Data Structures 정리

---

## 📌 Queue (큐)
- **FIFO**(First In, First Out, 선입선출) 방식의 자료구조  
- 먼저 들어온 데이터가 먼저 나감  

### 🔹 주요 연산  
- `enqueue (PUSH)`: 데이터 추가  
- `dequeue (POP)`: 데이터 제거  

---

## 📌 Stack (스택)
- **LIFO**(Last In, First Out, 후입선출) 방식의 자료구조  
- 나중에 들어온 데이터가 먼저 나감  

### 🔹 주요 연산  
- `push`: 데이터 추가  
- `pop`: 데이터 제거  

---

## 📌 Array (배열)
- 메모리에 **연속적인 공간**을 할당하여 데이터를 저장하는 구조  

### ✅ 배열 크기 증가 문제  
- 기존 배열을 확장할 때, 메모리에 연속된 공간이 부족하면 **새로운 배열을 생성하고 기존 데이터를 복사**해야 함  
- 이는 **시간과 메모리 비용이 증가**하는 단점이 있음  

### ✅ 배열 크기 확장의 대안  
- 기존 배열을 **동적 메모리 할당 (Dynamic Memory Allocation)** 을 이용해 확장  
- 특정 공간을 미리 확보해놓고 활용하는 방식 고려  

---

## 🛠️ 동적 배열 크기 확장 (C 예제)
```cpp
#include <stdio.h>
#include <stdlib.h> // malloc 사용을 위한 헤더

int main(void) {
    int *tmp = malloc(4 * sizeof(int)); // 새로운 배열 할당 (4개의 int 크기)
    if (tmp == NULL) {
        return 1; // 메모리 할당 실패 시 종료
    }

    int list[3] = {1, 2, 3}; // 기존 배열
    for (int i = 0; i < 3; i++) {
        tmp[i] = list[i]; // 기존 데이터 복사
    }

    tmp[3] = 4; // 새로운 데이터 추가

    for (int i = 0; i < 4; i++) {
        printf("%i\n", tmp[i]); // 새로운 배열 출력
    }

    free(tmp); // 동적 할당된 메모리 해제
    return 0;
}
```

## 📌 Linked List (연결 리스트)

배열의 크기 고정 문제를 해결하기 위해 **포인터**를 활용하여 데이터를 동적으로 연결하는 자료구조

## 🔹 배열 vs 연결 리스트 비교

|  | **배열 (Array)** | **연결 리스트 (Linked List)** |
| --- | --- | --- |
| **메모리 구조** | 연속된 메모리 공간 사용 | 메모리의 여러 위치에 분산 저장 |
| **크기 조정** | 변경 불가 (고정 크기) | 동적으로 크기 조절 가능 |
| **데이터 접근** | 인덱스로 O(1) 접근 가능 | 선형 탐색 O(n) |
| **삽입/삭제** | 느림 (중간 삽입/삭제 시 데이터 이동 필요) | 빠름 (포인터 변경만 필요) |
| **추가 메모리 비용** | 없음 | 각 노드마다 포인터 저장 공간 필요 |

---

## 🔹 연결 리스트의 핵심 개념

- **Node (노드)**: 데이터를 저장하는 단위
- **Pointer (포인터)**: 다음 노드의 주소를 저장하여 연결

📌 연결 리스트는 배열보다 **유연한 크기 조절이 가능**하지만, **포인터 유지 비용**이 추가로 발생함.  
따라서 **삽입/삭제가 잦은 경우**에는 연결 리스트가 유리하고, **빠른 접근이 필요한 경우**에는 배열이 유리함.

---

# 🔥 정리

1. **Queue (큐)** → FIFO 구조, 순차적으로 처리하는 작업에 유용
2. **Stack (스택)** → LIFO 구조, 되돌리기(Undo) 같은 기능에 유용
3. **Array (배열)** → 빠른 데이터 접근이 가능하지만 크기 변경이 어려움
4. **Linked List (연결 리스트)** → 유동적인 크기 조절이 가능하지만, 추가적인 포인터 메모리 비용이 발생