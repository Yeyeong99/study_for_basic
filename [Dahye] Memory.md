# Pixel Art

작은 정사각형 픽셀을 조합하여 그림을 만드는 디지털 아트 스타일. 8비트 및 16비트 비디오 게임의 그래픽 스타일에서 비롯되었으며, 마인크래프트, 슈퍼 마리오, 젤다 같은 레트로 게임에서 많이 볼 수 있음



**활용 분야**

- **비디오 게임**: 인디 게임(스타듀 밸리 등)에서 자주 사용됨
- **애니메이션**: 짧은 GIF 또는 움직이는 캐릭터 제작
- **NFT 아트**: 크립토펑크(CryptoPunks) 같은 NFT 프로젝트에서 인기
- **디지털 일러스트**: 감성적인 아트워크 제작

구글 스프레드 시트로 픽셀 아트 하는법 궁금하면 

https://hischarlie.tistory.com/46


### **픽셀(Pixel)이란?**

픽셀(Pixel, Picture Element)은 디지털 이미지를 구성하는 가장 작은 단위의 점(화소). 모든 디지털 이미지는 수많은 픽셀들이 모여서 만들어지며, 각 픽셀은 특정한 색상을 가지고 있음.

---

### **1. 픽셀의 기본 개념**

✅ **디지털 이미지의 최소 단위**

✅ **각 픽셀은 특정한 색상 값을 가짐**

✅ **여러 개의 픽셀이 모여 전체적인 이미지를 형성**

ex) 1920x1080 해상도의 모니터 화면은 **가로 1920개, 세로 1080개**의 픽셀로 구성되며, 총 **2,073,600개(약 200만 개)**의 픽셀이 존재

---

### **2. 픽셀의 색상 표현 방식**



보통 **RGB(Red, Green, Blue) 값**으로 표현

- **RGB 색상 모드**: 빨강(R), 초록(G), 파랑(B)의 조합으로 색을 표현 (0~255 값)
- 일반적인 24비트 색상 이미지에서는 한 픽셀이 **8비트(1바이트) × 3(R, G, B) = 24비트**로 저장됨

---

### **3. RGB 색상 코드와 HEX 코드**

웹 개발과 디자인에서는 RGB 값을 16진수(HEX 코드)로 변환하여 사용합니다.

- **RGB (255, 0, 0) → HEX 코드: #FF0000 (빨강)**
- **RGB (0, 255, 0) → HEX 코드: #00FF00 (초록)**
- **RGB (0, 0, 255) → HEX 코드: #0000FF (파랑)**
- 

💡 **웹에서 자주 사용하는 색상**

- 흰색: **#FFFFFF**
- 검은색: **#000000**
- 회색: **#808080**
- 파란색: **#0000FF**
- 초록색: **#008000**
- 빨간색: **#FF0000**

CSS에서 RGB 색상을 사용할 때는 다음과 같이 지정 가능

```css
css

color: rgb(255, 0, 0);  /* 빨강 */
background-color: #00FF00;  /* 초록 */

```

---

### **4. 8비트와 255의 관계**

RGB에서 255라는 숫자가 나오는 이유는 컴퓨터가 색상을 표현할 때 8비트(1바이트)를 사용하기 때문이며, 이는 16진수(HEX) 표현 방식과도 밀접한 관련이 있음

컴퓨터는 **이진수(0과 1)로 데이터를 처리**

- **1비트(bit)** → 0 또는 1 (2개의 값)
- **8비트(1바이트)** → 00000000 ~ 11111111 (총 256개 값)
- 

**8비트로 표현할 수 있는 최대 숫자**는:

28=2562^8 = 256

28=256

즉, 0부터 255까지 **총 256개의 값**을 표현 가능

RGB 색상에서 **각 채널(R, G, B)은 8비트로 표현**되므로:

- **RGB (255, 0, 0)** → 순수한 빨강
- **RGB (0, 255, 0)** → 순수한 초록
- **RGB (0, 0, 255)** → 순수한 파랑
- **RGB (255, 255, 255)** → 흰색 (세 가지 빛이 모두 최대)
- **RGB (0, 0, 0)** → 검은색 (세 가지 빛이 모두 없음)

---

## **5. 16진수(HEX)와의 관계**

**16진수는 0~~9, A~~F (총 16개 숫자)로 구성**되며, 8비트(0~255)를 16진수로 변환하면 **두 자리(00~FF)로 표현 가능**

### **RGB → HEX 변환 예시**

| RGB 값 | 10진수 | 2진수 (8비트) | 16진수 (HEX) |
| --- | --- | --- | --- |
| 0 | 00000000 | 00 |  |
| 255 | 11111111 | FF |  |
| 128 | 10000000 | 80 |  |
| 64 | 01000000 | 40 |  |
| 192 | 11000000 | C0 |  |

예를 들어, **RGB (255, 165, 0)** (주황색)을 HEX로 변환하면:

- **255 → FF**
- **165 → A5**
- **0 → 00**

**HEX 값은 #FFA500**이 됨. 

💡 **예시**

- **RGB (255, 0, 0) → #FF0000 (빨강)**
- **RGB (0, 255, 0) → #00FF00 (초록)**
- **RGB (0, 0, 255) → #0000FF (파랑)**
- **RGB (128, 128, 128) → #808080 (회색)**

---

# 요약:

## **RGB에서 255를 사용하는 이유**

✔ **8비트(1바이트)로 표현 가능** → 0~255의 숫자를 사용하면 256개 색상을 만들 수 있음

✔ **컴퓨터가 2진수(00000000~11111111)로 색상을 처리하기 쉬움**

✔ **16진수(HEX) 표현과 연동이 쉬워 웹과 그래픽 디자인에서 활용 가능**

---

# Memory

컴퓨터의 메모리(기억장치)는 **2진수(0과 1)**로 동작하지만 사람이 다루기엔 길고 비효율적. 

 그래서 **메모리 주소나 데이터 표현에 16진수(HEX)** 사용

---

## **16진수 ↔ 2진수**

16진수는 한 자리(0~F)로 **4비트(2진수 4자리)**를 표현 가능하므로 ****8비트(1바이트)는 **16진수 2자리**로 변환됨. 

| 2진수(8비트) | 16진수(HEX) |
| --- | --- |
| 0000 0000 | 00 |
| 0000 1111 | 0F |
| 1111 1111 | FF |
| 1100 1100 | CC |

👉 **즉, 16진수는 2진수를 4배 더 효율적으로 줄여서 표현 가능!** 

---

## **1. 메모리 주소에서 16진수를 사용하는 이유**

컴퓨터의 메모리는 **각 바이트(8비트)마다 고유한 주소를 가짐.**  **메모리 주소를 표현할 때 16진수를 사용**하는 것이 일반적. 

💡 **예제: 메모리 주소 표현 (16진수 vs. 10진수 vs. 2진수)**

| 2진수 주소 | 10진수 주소 | 16진수 주소 |
| --- | --- | --- |
| 0000 0000 0000 0000 | 0 | 0x0000 |
| 0000 0000 0000 0001 | 1 | 0x0001 |
| 0000 0000 1111 1111 | 255 | 0x00FF |
| 0000 1111 1111 1111 | 4095 | 0x0FFF |
| 1111 1111 1111 1111 | 65535 | 0xFFFF |

👉 **10진수 주소:** 너무 크고 다루기 불편함

👉 **2진수 주소:** 너무 길고 가독성이 떨어짐

👉 **16진수 주소:** 짧고 이해하기 쉬움

→ **결론: 운영체제(OS), 프로그래밍 언어(C, C++, Assembly)에서 메모리 주소는 16진수로 표현!**

---

## **2. 16진수가 쓰이는 곳**

### **(1) 메모리 주소**

운영체제(OS)에서 프로그램을 실행할 때, 메모리 주소를 **16진수**로 표시

💻 **예제 (메모리 주소 출력)**

```

0x7FFE2376ABCD
0x0040FF12
0xB8000000

#0x 16진수임을 나타내는 표기

```

### **(2) 어셈블리 코드 (저수준 프로그래밍)**

**C 언어, 어셈블리(Assembly) 프로그래밍**에서 메모리 주소를 다룰 때 16진수 사용

```
assembly

MOV AX, 0x1234  ; AX 레지스터에 16진수 1234 값을 저장
MOV BX, 0xABCD  ; BX 레지스터에 16진수 ABCD 값을 저장

```

### **(3) 그래픽 색상 코드 (RGB)**

웹 디자인, 포토샵 등에서 RGB 색상을 16진수로 표현합니다.

| 색상 | RGB 값 | 16진수 (HEX) |
| --- | --- | --- |
| 빨강 | (255, 0, 0) | #FF0000 |
| 초록 | (0, 255, 0) | #00FF00 |
| 파랑 | (0, 0, 255) | #0000FF |

---

## **4. 요약: 메모리에 16진수 쓰는 이유**

- **2진수는 너무 길어서 사람이 이해하기 어려움**
- **16진수는 2진수보다 짧고, 한 자리(0~F)로 4비트를 표현 가능**
- **운영체제(OS)와 프로그래밍에서 메모리 주소를 16진수로 표시**
- **어셈블리, 네트워크, RGB 색상, 메모리 덤프, 디버깅 등에 16진수가 사용됨**

**→즉, 메모리는 2진수를 직접 사용하지만, 사람이 보기 쉽게 16진수를 관례적으로 사용**

---

### **정보의 주소란?**

**메모리(기억장치) 안에서 특정 데이터를 저장하는 위치**

이것을 **메모리 주소(Memory Address)**라고 하며, 운영체제(OS)와 프로그램이 데이터를 찾고 관리하는 데 사용됩니다.

---

## **1. 주소(Address)의 개념**

우리가 사는 집에도 **주소(예: 서울특별시 강남구 ~번지)**가 있어서 사람들이 찾을 수 있죠?

📍 **컴퓨터도 데이터를 저장하는 공간(메모리)에 "주소"를 부여하여 정보를 찾을 수 있게 합니다.**

💡 예제

- **집 주소:** 서울특별시 강남구 123-45번지
- **메모리 주소:** `0x7FFE1234ABCD` (16진수)

**즉, "정보의 주소"란 컴퓨터가 데이터를 저장한 "위치"를 가리키는 것**입니다.

---

## **2. 메모리 주소 (Memory Address)란?**

컴퓨터의 메모리는 **RAM(Random Access Memory)**에 저장되며, 이곳에 있는 모든 데이터는 **"주소(Address)"**를 가집니다.

💻 **예제 (메모리 주소)**

```
arduino
복사편집
0x1000  → 숫자 42 저장
0x1004  → 숫자 99 저장
0x1008  → "Hello" 문자열 저장

```

📌 `0x1000`, `0x1004`, `0x1008` 등이 **정보(데이터)의 주소**입니다.

---

## **3. 예제: 메모리 주소를 활용하는 C 코드**

```c
c
복사편집
#include <stdio.h>

int main() {
    int a = 42;  // 변수 a에 42 저장
    printf("a의 값: %d\n", a);
    printf("a의 주소: %p\n", &a); // &a = 변수 a의 메모리 주소
    return 0;
}

```

🖥 실행 결과

```

a의 값: 42
a의 주소: 0x7ffe1234abcd

```

👉 변수 `a`는 **메모리 어딘가(예: 0x7ffe1234abcd)에 저장됨**

👉 `&a`는 `a`가 저장된 메모리 주소를 출력함

---

## **4. 메모리 주소가 필요한 이유**

### ✅ **(1) 데이터를 찾을 수 있음**

- 프로그램이 실행될 때, 메모리는 **엄청나게 많은 데이터**를 저장합니다.
- 주소가 없으면 원하는 데이터를 빠르게 찾을 수 없습니다.

### ✅ **(2) 포인터 (Pointer) 사용 가능**

- C, C++ 같은 언어에서는 **"포인터(pointer)"**를 사용하여 메모리 주소를 직접 조작할 수 있습니다.
- **예제:**
    
    ```c
    c
    복사편집
    int a = 10;
    int *ptr = &a;  // ptr은 a의 주소를 저장하는 포인터
    printf("%d", *ptr);  // ptr이 가리키는 값 출력 (10)
    
    ```
    

### ✅ **(3) 동적 메모리 할당**

- 프로그램이 실행될 때 메모리를 **동적으로 할당**하려면 주소가 필요합니다.
- **예제 (C에서 `malloc` 사용)**
    
    ```c
    c
    복사편집
    int *p = (int*)malloc(sizeof(int)); // 새로운 메모리 할당
    *p = 20;  // 해당 메모리에 20 저장
    
    ```
    

---

## **5. 메모리 주소와 16진수 (Hexadecimal)**

컴퓨터는 **2진수(0과 1)를 사용**하지만, 메모리 주소는 **16진수(HEX)**로 표시됩니다.

- 이유: 2진수는 너무 길기 때문에 16진수로 줄여서 사용
- 예:
    
    ```
    yaml
    복사편집
    2진수  →  1100 1100 1010 1010
    16진수 →  0xCCAA  (더 짧고 읽기 쉬움)
    
    ```
    

💡 **운영체제(OS)와 프로그래밍 언어에서 메모리 주소는 항상 16진수로 표시됩니다.**

📌 예제: `0x7FFE1234ABCD`

---

## **6. 정보의 주소(메모리 주소) 요약**

✔ **컴퓨터의 메모리는 각 데이터가 저장된 고유한 "주소"를 가짐**

✔ **이 주소를 통해 데이터를 찾고 수정할 수 있음**

✔ **C/C++에서는 포인터를 사용하여 직접 메모리 주소 조작 가능**

✔ **운영체제(OS)와 프로그래밍에서는 메모리 주소를 16진수(HEX)로 표현**

📌 **즉, "정보의 주소"는 컴퓨터가 데이터를 저장한 위치를 가리키는 메모리 주소를 의미합니다!** 😊

궁금한 점 있으면 더 질문해 주세요! 🚀

---

## **1. 엠퍼샌드(&)란?**

엠퍼샌드(&)는 원래 **"and"를 의미하는 기호**이며,

**프로그래밍과 수학, 웹 개발 등 다양한 분야에서 사용됨**

- **C/C++에서 주소 연산자 (메모리 주소 찾기)**
- **C/C++에서 비트 연산 (AND 연산)**
- **Python, JavaScript 등에서 논리 연산 (AND 연산자)**
- **HTML에서 특수문자 인코딩 (`&lt;`, `&amp;`)**

---

## **2. 엠퍼샌드(&)사용법**

### **✅ (1) C/C++에서 주소 연산자 (메모리 주소 가져오기)**

C/C++에서는 `&`를 **"주소 연산자"**라고 하며, **변수의 메모리 주소를 가져올 때 사용**합니다.

```c
c
복사편집
#include <stdio.h>

int main() {
    int a = 10;
    printf("a의 값: %d\n", a);
    printf("a의 메모리 주소: %p\n", &a); // &a → 변수 a의 주소
    return 0;
}

```

🖥 **출력 예시**

```
less
복사편집
a의 값: 10
a의 메모리 주소: 0x7ffeefbff56c

```

📌 **여기서 `&a`는 변수 `a`가 저장된 메모리 주소를 의미!**

📌 **즉, `&` 기호는 "변수의 주소를 가져오는" 역할을 합니다.**

---

### **✅ (2) C/C++에서 포인터 연산**

엠퍼샌드(`&`)는 **포인터(pointer)와 함께 사용**될 때, 변수의 주소를 포인터에 저장할 수 있습니다.

```c
c
복사편집
#include <stdio.h>

int main() {
    int a = 10;
    int *ptr = &a;  // ptr에 a의 주소 저장

    printf("a의 값: %d\n", a);
    printf("ptr이 가리키는 값: %d\n", *ptr); // *ptr → 주소에서 값 가져오기
    return 0;
}

```

📌 `ptr = &a;` → `ptr`은 변수 `a`의 메모리 주소를 가짐

📌 `*ptr` → `ptr`이 가리키는 주소의 값을 가져옴

---

### **✅ (3) C/C++에서 비트 연산 (AND 연산자)**

엠퍼샌드(`&`)는 **비트 연산에서 AND 연산**을 수행할 때 사용됩니다.

- **AND 연산**: 두 비트가 모두 1이면 1, 아니면 0
- **예제:**
    
    ```
    markdown
    복사편집
    5  →  0101 (2진수)
    3  →  0011 (2진수)
    ------------------
    5 & 3 → 0001 (1)
    
    ```
    
- **C 코드 예제:**
    
    ```c
    c
    복사편집
    #include <stdio.h>
    
    int main() {
        int a = 5, b = 3;
        printf("a & b = %d\n", a & b); // 결과: 1
        return 0;
    }
    
    ```
    

📌 `5 & 3` → 비트 단위 AND 연산을 수행하여 결과는 `1`

---

### **✅ (4) Python, JavaScript 등의 논리 연산**

Python과 JavaScript에서는 `&`가 **논리 AND 연산**(True/False 계산)에 사용될 수 있습니다.

```python
python
복사편집
print(5 & 3)  # 1

```

👉 **비트 단위로 연산 수행**

👉 **두 수의 AND 연산 결과를 반환**

---

### **✅ (5) HTML에서 특수 문자 표현**

HTML에서는 엠퍼샌드(`&`)를 특수 문자 표현에 사용합니다.

예를 들어, `<`(작다)는 HTML에서 그대로 쓰면 코드로 인식되므로 **`&lt;`**로 변환합니다.

💡 **HTML에서 엠퍼샌드 사용 예시**

- `&lt;` → `<` (작다)
- `&gt;` → `>` (크다)
- `&amp;` → `&` (앰퍼샌드 자체)

```html
html

<p>10 &lt; 20 (10은 20보다 작다)</p>

```

👉 출력 결과: `10 < 20 (10은 20보다 작다)`

---

## **3. 요약**

✔ **주소 연산자 (`&변수`)** → C/C++에서 변수의 주소 가져오기

✔ **비트 AND 연산 (`a & b`)** → 두 수의 비트 연산

✔ **논리 연산 (Python, JavaScript)** → True/False 논리 연산

✔ **HTML 특수문자 (`&lt;`, `&amp;`)** → `<`, `&` 등의 문자 표현

# Pointer

**메모리 주소를 저장하는 변수. 다른 변수의 주소를 가리키는 역할**을 함.

💡 **일반 변수 vs. 포인터 변수 비교**

| 개념 | 일반 변수 | 포인터 변수 |
| --- | --- | --- |
| 저장값 | 데이터 (예: 10, 'A') | 메모리 주소 (예: 0x7ffe1234) |
| 사용 목적 | 직접 값을 저장 | 다른 변수의 주소를 저장하고 참조 |
| 예제 | `int a = 10;` | `int *p = &a;` |

---

## 1. 포인터 사용처

**예) 메모리 직접 접근, 동적 메모리 할당, 효율적인 데이터 처리** 등..

### **(1) 변수의 메모리 주소를 알 수 있음**

- 모든 변수는 **메모리 어딘가에 저장**되는데, 포인터를 사용하면 변수의 메모리 주소 확인 가능

### **(2) 동적 메모리 할당 가능 (`malloc` 등)**

- 프로그램 실행 중 **메모리를 동적으로 할당할 때 필수**
- 배열의 크기를 동적으로 변경할 때 사용됨

### **(3) 배열과 문자열을 효율적으로 처리**

- **배열과 문자열을 더 효과적으로 관리**하는 데 도움

### **(4) 함수에서 Call by Reference (참조에 의한 호출) 가능**

- 포인터를 사용하면 **함수에서 원래 변수 값을 직접 변경 가능**

---

## **2. 포인터 사용법 (C/C++ 기준)**

### **(1) 포인터 변수 선언**

`*`(애스터리스크)를 사용하여 선언

```c
c
복사편집
int a = 10;    // 일반 변수 선언
int *p;        // 포인터 변수 선언
p = &a;        // 포인터 p에 변수 a의 주소 저장

```

- `int *p;` → `p`는 **정수를 가리키는 포인터 변수**
- `p = &a;` → `p`에 `a`의 **메모리 주소** 저장

---

### **(2) 포인터로 값 접근 ( 연산자 사용)**

포인터를 통해 원본 변수의 값을 가져올 수도 있음

```c
c

#include <stdio.h>

int main() {
    int a = 10;
    int *p = &a;  // 포인터 p에 a의 주소 저장

    printf("a의 값: %d\n", a);      // 10 출력
    printf("a의 주소: %p\n", &a);   // a의 메모리 주소 출력
    printf("포인터 p가 가리키는 값: %d\n", *p); // 10 출력
}

```

**출력 예시**

```

a의 값: 10
a의 주소: 0x7ffe1234
포인터 p가 가리키는 값: 10

```

 `*p`는 **p가 가리키는 주소의 값을 가져옴**

 `&a`는 **변수 a의 주소를 나타냄**

---

### **(3) 포인터를 이용한 값 변경**

포인터를 사용하면 **변수의 값을 직접 변경** 가능

```c

#include <stdio.h>

int main() {
    int a = 10;
    int *p = &a;

    *p = 20;  // 포인터를 이용해 a의 값을 변경

    printf("a의 값: %d\n", a);  // 20 출력
    return 0;
}

```

 `*p = 20;` → 포인터 `p`가 가리키는 주소의 값을 `20`으로 변경

따라서 **변수 `a`의 값이 변경됨** (포인터를 이용해 간접적으로 변경)

---

## **3. 포인터 사용시 주의점**

**(1) 초기화되지 않은 포인터 사용 금지**

```c

int *p;
*p = 10;  // 잘못된 접근 (쓰레기 값이 저장된 주소를 가리킬 가능성)

```

- **포인터는 반드시 초기화해야 함**
- 올바른 방법: `int *p = NULL;` 또는 `p = &변수;`

**(2) 잘못된 메모리 접근 금지**

```c

int *p = NULL;
printf("%d", *p);  // 잘못된 접근 (NULL 포인터 참조)

```

- NULL 포인터는 사용 전에 반드시 유효한 메모리를 할당해야 함

**(3) 동적 메모리 할당 후 `free()`로 해제 필요**

```c

int *p = (int*)malloc(sizeof(int));
free(p);  // 사용 후 메모리 해제

```

동적 할당한 메모리는 반드시 `free()`로 해제해야 **메모리 누수 방지**

---

## **→요약**

- **포인터는 메모리 주소를 저장하는 변수**
- `&` → 변수의 주소 가져오기
- `*` → 포인터가 가리키는 값 참조하기
- **배열, 동적 메모리 할당, 함수 호출(Call by Reference)에서 활용됨**
- **잘못된 포인터 사용은 프로그램 오류를 초래하니 주의!**

---

# Strings

### `null` 문자란?

 `'\0'`로 표시되며, 문자열의 끝을 나타내는 특별한 문자

C 언어에서는 문자열을 단순한 문자 배열로 저장하는데, 문자열의 끝을 명확하게 구분하기 위해 항상 마지막에 `null` 문자가 들어감. 덕분에 `printf()` 같은 함수가 문자열을 출력할 때 어디까지 읽어야 하는지 알 수 있음

예를 들어, `"hi!"`는 문자 하나 당 1바이트를 차지하고, 내부적으로 아래처럼 저장됨.

```

| 'h' | 'i' | '!' | '\0' |

총 4바이트

```

만약 `null` 문자가 없으면, 프로그램이 메모리에서 문자열을 읽을 때 어디까지 읽어야 하는지 알 수 없어서 오류 발생할 수 있음. 

```c
c

char *s = "Hi!";

```

### `char *s`

- **문자 포인터**로, `s`는 `char` 타입 값을 가리키는 포인터.
- `s`는 `"Hi!"`의 첫 번째 문자인 `'H'`의 메모리 주소를 저장하고 있음
- 즉, `s`를 통해 `"Hi!"`의 각 문자에 접근 가능

### 메모리 구조:

```

 주소    값
 ----   ----
 1000 | 'H'
 1001 | 'i'
 1002 | '!'
 1003 | '\0'

```

그리고 `s`에는 `1000` (첫 번째 문자의 주소)이 저장됨.

---

```c
c

typedef char *string;

```

### 1. `typedef`란?

- **자료형에 새로운 이름(별칭, alias)** 을 붙이는 키워드
- 기존의 자료형을 더 읽기 쉽게 만들거나 코드를 간결하게 함

### 2. `char *string`이 의미하는 것

- 원래 `char *`는 **문자열을 가리키는 포인터**를 의미
- `typedef char *string;`을 선언하면, `string`이 `char *`의 **별칭**이

### 3. 사용 예시

```c
c

#include <stdio.h>

typedef char *string;  // char *의 별칭을 string으로 지정

int main() {
    string s = "Hello, world!";  // char *s와 동일
    printf("%s\n", s);  // 출력: Hello, world!
    return 0;
}

```

`string`을 `char *`처럼 사용할 수 있어서, 코드 가독성 향상
